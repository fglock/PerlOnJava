# Memory Usage Analysis: Compiler vs Interpreter for Large Ranges

## Summary

The runtime is the same for both compiler and interpreter. The difference in memory usage comes from how ranges are handled during foreach loop compilation.

## Current Findings

### Both Use Same Runtime
- Both compiler and interpreter use `PerlRange.java` and `PerlRangeIntegerIterator`
- Both support lazy iteration without materializing the full range
- The interpreter bytecode shows: `LOAD_CONST r6 = constants[0] (PerlRange{1..50000000})`

### Compiler Bytecode Generation

From `--disassemble` output for `for (1..100) { }`:
```
INVOKESTATIC org/perlonjava/runtime/PerlRange.createRange (...)
INVOKEVIRTUAL org/perlonjava/runtime/RuntimeBase.getArrayOfAlias ()
ASTORE 28
```

**Problem**: The compiler calls `getArrayOfAlias()` which materializes the entire range!

### Memory Tests

Both compiler and interpreter work down to 4MB heap:
```bash
JAVA_OPTS="-Xmx4m" ./jperl -e 'my $x; for my $v (1..50_000_000) { $x++ }; print $x, "\n";'  # Works
JAVA_OPTS="-Xmx4m" ./jperl --interpreter -e 'my $x; for my $v (1..50_000_000) { $x++ }; print $x, "\n";'  # Works
```

This suggests the named loop variable case (`for my $v`) takes a different (optimized) path than implicit `$_`.

### Code Analysis

In `EmitForeach.java` line 310-330, there IS code to avoid materializing PerlRange:

```java
// IMPORTANT: avoid materializing huge ranges.
// PerlRange.setArrayOfAlias() currently expands to a full list, which can OOM
// in Benchmark.pm (for (1..$n) with large $n).
Label notRangeLabel = new Label();
Label afterIterLabel = new Label();
mv.visitInsn(Opcodes.DUP);
mv.visitTypeInsn(Opcodes.INSTANCEOF, "org/perlonjava/runtime/PerlRange");
mv.visitJumpInsn(Opcodes.IFEQ, notRangeLabel);

// Range: iterate directly.
mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "org/perlonjava/runtime/RuntimeBase", "iterator", "()Ljava/util/Iterator;", false);
```

However, this optimization is only applied when `isGlobalUnderscore` is true (line 293).

### Root Cause

The INSTANCEOF check is not appearing in the disassembly, which means:

1. Either the `isGlobalUnderscore` path is not being taken
2. Or there's an earlier path that calls `getArrayOfAlias()` before the optimization check

Looking at line 251-253:
```java
boolean isGlobalUnderscore = node.needsArrayOfAlias ||
                             (loopVariableIsGlobal && globalVarName != null &&
                              (globalVarName.equals("main::_") || globalVarName.endsWith("::_")));
```

For `for (1..100) { }`, the implicit `$_` should trigger `isGlobalUnderscore = true`.

### Fix Applied ✅

**Commit**: be451254

The issue was that the INSTANCEOF PerlRange optimization only existed in the `isGlobalUnderscore` code path (for implicit `$_`), but was missing from the standard path used for lexical loop variables like `for my $v (1..N)`.

**Changes made**:
- Added INSTANCEOF check to the standard foreach path (line 331-355 in EmitForeach.java)
- Both code paths now check if the iterable is a PerlRange
- If yes: call `.iterator()` directly (lazy, no materialization)
- If no: call `.iterator()` on the base type (arrays still alias correctly)

**Results**:
- ✅ Large ranges (1..50_000_000) now work with minimal memory (tested down to 4MB heap)
- ✅ All tests pass
- ✅ Array aliasing semantics preserved
- ✅ Range loop variables remain modifiable lvalues
- ✅ Compiler now matches interpreter efficiency

**Disassembly verification**:
```
INVOKESTATIC org/perlonjava/runtime/PerlRange.createRange (...)
DUP
INSTANCEOF org/perlonjava/runtime/PerlRange
IFEQ L1
INVOKEVIRTUAL org/perlonjava/runtime/RuntimeBase.iterator ()
```

The INSTANCEOF check now appears in the generated bytecode, ensuring ranges use lazy iteration.