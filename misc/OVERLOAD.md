# Perl Overload Internal Implementation Guide
For PerlOnJava Implementation

This documentation provides a guide for implementing Perl's overload system the PerlOnJava project.

## Core Mechanisms

### 1. Symbol Table Storage
Overloaded operators are stored in the package's symbol table using special naming conventions:
- `package::((` - Primary overload marker
- `package::()` - Fallback settings storage
- `package::(op` - Individual operator implementations (where 'op' is the operator name)

### 2. Magic Markers
Two special methods indicate overloading presence:
- '((' - Primary marker installed in every overloaded package
- '()' - Secondary marker holding fallback configuration

### 3. Operator Registration Process
When registering overloaded operators:
1. Install '((' marker using nil subroutine
2. For each operator:
   - Create symbol table entry `package::(operator`
   - Store implementation (coderef or method name)
3. Handle fallback settings in '()' marker

### 4. Method Resolution
Resolution order for operator calls:
1. Direct method lookup in current package
2. Inheritance chain traversal
3. Autogeneration via fallback
4. Built-in operator behavior (if fallback=TRUE)

### 5. Inheritance Implementation
- Overload magic propagates through @ISA hierarchy
- Child classes inherit parent overloads
- Individual operators can be overridden
- Method resolution follows standard Perl inheritance rules

## Optimization Opportunities

### 1. Symbol Table Access
- Cache symbol table lookups
- Use direct method pointers where possible
- Maintain operator-to-method mapping table

### 2. Method Dispatch
- Avoid repeated inheritance chain traversal
- Cache resolved methods per class
- Pre-compute common operation paths

### 3. Autogeneration
- Cache generated methods
- Implement common combinations directly
- Optimize numeric/string conversion paths

## Fallback System

### 1. Fallback Modes
- undefined: Enable magic autogeneration
- TRUE: Allow built-in operations
- FALSE: Disable autogeneration

### 2. Autogeneration Rules
Operator dependencies for autogeneration:
- Numeric: 0+ → bool → ""
- String: "" → 0+ → bool
- Comparison: <=> → eq,ne,lt,gt,le,ge
- Assignment: op → op=

### 3. Method Selection
Priority order:
1. Explicitly defined method
2. Autogenerated method
3. Built-in operation (if fallback=TRUE)
4. Error condition

## Special Cases

### 1. Copy Constructor
- Triggered before mutator operations
- Creates deep copy of object state
- Essential for maintaining value semantics

### 2. Conversion Operations
- stringify ("") 
- numify (0+)
- boolean (bool)
- Special handling in context-sensitive operations

### 3. Assignment Operators
- Don't modify original operands
- Return new values
- Handle tied variables correctly

## Implementation Requirements

### 1. Core Data Structures
```java
class OverloadTable {
    Map<String, Method> operators;
    boolean fallback;
    Method copyConstructor;
}

class OverloadMethod {
    Method implementation;
    boolean isAutoGenerated;
    String sourceOperator;  // for autogenerated methods
}
```

### 2. Method Signatures
All overloaded methods must support:
- Left operand (object)
- Right operand (or undef)
- Swap flag
- Optional context information

### 3. Context Handling
Track and propagate:
- Numeric context
- String context
- Boolean context
- Assignment context

## Performance Considerations

### 1. Method Cache
- Cache resolved methods per class
- Clear cache on method redefinition
- Consider weak references for memory management

### 2. Fast Paths
Implement direct dispatch for:
- Common numeric operations
- String concatenation
- Comparison operations
- Boolean contexts

### 3. Memory Optimization
- Lazy method resolution
- Shared autogeneration templates
- Efficient symbol table structure

## Error Handling

### 1. Invalid Operations
- Check operator validity
- Proper error messages
- Fallback behavior

### 2. Type Errors
- Handle mixed-type operations
- Proper type conversion
- Context-specific errors

### 3. Inheritance Errors
- Method resolution failures
- Inconsistent override detection
- Circular reference detection

## Testing Requirements

### 1. Functionality Tests
- Basic operator overloading
- Inheritance behavior
- Autogeneration rules
- Fallback scenarios

### 2. Performance Tests
- Method dispatch speed
- Memory usage patterns
- Cache effectiveness
- Comparison with Perl implementation

### 3. Edge Cases
- Mixed-type operations
- Complex inheritance chains
- Recursive operations
- Context sensitivity

## Migration Notes

### 1. Perl to Java Mapping
- Symbol table → Class metadata
- Method resolution → Java method dispatch
- Type system integration
- Context propagation

### 2. Java-specific Optimizations
- Use method handles
- Leverage JVM inlining
- Optimize memory layout


