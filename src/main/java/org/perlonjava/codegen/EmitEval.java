package org.perlonjava.codegen;

import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.perlonjava.CompilerOptions;
import org.perlonjava.astnode.EvalOperatorNode;
import org.perlonjava.astnode.OperatorNode;
import org.perlonjava.astvisitor.EmitterVisitor;
import org.perlonjava.runtime.RuntimeArray;
import org.perlonjava.runtime.RuntimeCode;
import org.perlonjava.runtime.RuntimeContextType;
import org.perlonjava.symbols.ScopedSymbolTable;

/**
 * EmitEval handles the bytecode generation for Perl's eval operator.
 *
 * <h2>Overview</h2>
 * The eval operator in Perl compiles and executes a string at runtime. This implementation
 * generates bytecode that will:
 * <ol>
 *   <li>Capture the current lexical environment (closure variables)</li>
 *   <li>Compile the eval string into a new Java class at runtime</li>
 *   <li>Instantiate the class with captured variables</li>
 *   <li>Execute the compiled code</li>
 * </ol>
 *
 * <h2>Design Decisions</h2>
 * <ul>
 *   <li><b>Dynamic Class Generation:</b> Each eval creates a new class (e.g., anon5, anon6)
 *       because each eval may have different captured variables, even for identical strings</li>
 *   <li><b>EvalTag System:</b> A unique evalTag (e.g., "eval12") is generated at compile-time
 *       for each eval site. This tag links the runtime eval to its compile-time context</li>
 *   <li><b>Reflection for Instantiation:</b> We use Constructor.newInstance() rather than
 *       direct instantiation because class names are generated at runtime</li>
 *   <li><b>Global ClassLoader:</b> All eval classes use GlobalVariable.globalClassLoader
 *       to ensure they can reference each other and share the same namespace</li>
 * </ul>
 *
 * <h2>Performance Characteristics</h2>
 * <ul>
 *   <li>First execution of an eval string requires full compilation (slow)</li>
 *   <li>Repeated execution of identical eval strings in the same context uses cached classes (fast)</li>
 * </ul>
 *
 * <h2>Memory Considerations</h2>
 * Each eval creates a new class that remains loaded until the global class loader is reset.
 * Long-running applications that generate many unique eval strings should monitor memory usage.
 *
 */
public class EmitEval {
    /**
     * Handles the emission of bytecode for the Perl 'eval' operator.
     *
     * <h3>Bytecode Generation Flow</h3>
     * <pre>
     * 1. Push eval string onto stack
     * 2. Call evalStringHelper(string, evalTag) â†’ returns Class
     * 3. Create Class[] array of parameter types (for captured variables)
     * 4. Get constructor via reflection: class.getConstructor(paramTypes)
     * 5. Create Object[] array of captured variable values
     * 6. Instantiate: constructor.newInstance(args)
     * 7. Convert to CODE reference: makeCodeObject(instance)
     * 8. Execute: RuntimeCode.apply(code, @_, context)
     * </pre>
     *
     * <h3>Example Perl Code</h3>
     * <pre>
     * my $x = 10;
     * my $y = 20;
     * my $result = eval '$x + $y';  # Captures $x and $y
     * </pre>
     *
     * <h3>Generated Bytecode Pattern</h3>
     * The generated bytecode effectively does:
     * <pre>
     * Class clazz = RuntimeCode.evalStringHelper(evalString, "eval123");
     * Constructor ctor = clazz.getConstructor(new Class[]{RuntimeScalar.class, RuntimeScalar.class});
     * Object instance = ctor.newInstance(new Object[]{$x, $y});
     * RuntimeScalar code = RuntimeCode.makeCodeObject(instance);
     * RuntimeList result = RuntimeCode.apply(code, @_, wantarray);
     * </pre>
     *
     * @param emitterVisitor The visitor that traverses the AST
     * @param node The OperatorNode representing the eval operation (contains the eval string expression)
     */
    static void handleEvalOperator(EmitterVisitor emitterVisitor, OperatorNode node) {
        EmitterContext ctx = emitterVisitor.ctx;
        MethodVisitor mv = ctx.mv;

        // Log current symbol table state for debugging
        emitterVisitor.ctx.logDebug("(eval) ctx.symbolTable.getAllVisibleVariables");

        // Capture the current lexical environment
        // This creates a snapshot of all variables visible at this eval site
        ScopedSymbolTable newSymbolTable = emitterVisitor.ctx.symbolTable.snapShot();
        if (node instanceof EvalOperatorNode evalOperatorNode) {
            // Preserve any special flags from the parse-time symbol table
            newSymbolTable.copyFlagsFrom(evalOperatorNode.getSymbolTable());
        }

        // Get list of all captured variable names
        String[] newEnv = newSymbolTable.getVariableNames();
        emitterVisitor.ctx.logDebug("evalStringHelper newSymbolTable: " + newSymbolTable);

        // Generate unique identifier for this eval site
        // This counter is incremented globally, ensuring each eval gets a unique tag
        int counter = EmitterMethodCreator.classCounter++;

        // Create compiler options specific to this eval
        // The filename becomes "(eval N)" for better error messages
        CompilerOptions compilerOptions = emitterVisitor.ctx.compilerOptions.clone();
        compilerOptions.fileName = "(eval " + counter + ")";

        // The evalTag is crucial - it links the runtime eval to this compile-time context
        // When evalStringHelper is called at runtime, it uses this tag to retrieve
        // the saved EmitterContext with the correct symbol table and compiler options
        String evalTag = "eval" + counter;

        // Create and save the EmitterContext for this eval
        // This context will be retrieved at runtime when the eval string is compiled
        EmitterContext evalCtx = new EmitterContext(
                null, // Java class name will be generated at runtime
                newSymbolTable,
                null, // method visitor not needed yet
                null, // class writer not needed yet
                emitterVisitor.ctx.contextType,
                true, // is boxed
                emitterVisitor.ctx.errorUtil,
                compilerOptions,
                new RuntimeArray());

        // Store the context in a static map, indexed by evalTag
        // This allows the runtime compilation to access the compile-time environment
        RuntimeCode.evalContext.put(evalTag, evalCtx);

        // Generate bytecode to evaluate the eval string expression
        // This pushes the string value onto the stack
        node.operand.accept(emitterVisitor.with(RuntimeContextType.SCALAR));
        // Stack: [RuntimeScalar(String)]

        if (node.operator.equals("evalbytes")) {
            // For evalbytes, verify the string contains valid bytes
            ctx.mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(
                    Opcodes.INVOKESTATIC,
                    "org/perlonjava/runtime/ScalarUtils",
                    "assertBytes",
                    "(Lorg/perlonjava/runtime/RuntimeScalar;)V",
                    false);
        }

        // Push the evalTag that links to the saved context
        mv.visitLdcInsn(evalTag);
        // Stack: [RuntimeScalar(String), String]

        // Call evalStringHelper to compile the eval string at runtime
        // This method:
        // 1. Retrieves the EmitterContext using evalTag
        // 2. Parses and compiles the eval string
        // 3. Returns the generated Class object
        // 4. Caches the result for repeated evals of the same string
        mv.visitMethodInsn(
                Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/RuntimeCode",
                "evalStringHelper",
                "(Lorg/perlonjava/runtime/RuntimeScalar;Ljava/lang/String;)Ljava/lang/Class;",
                false);
        // Stack: [Class]

        // Calculate how many variables need to be passed to the constructor
        // We skip 'this', '@_', and 'wantarray' which are handled separately
        int skipVariables = EmitterMethodCreator.skipVariables;

        // Create array of parameter types for the constructor
        // Each captured variable becomes a constructor parameter
        mv.visitIntInsn(Opcodes.BIPUSH, newEnv.length - skipVariables);
        mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Class");
        // Stack: [Class, Class[]]

        // Fill the parameter types array based on variable types
        // Variables starting with @ are RuntimeArray, % are RuntimeHash, others are RuntimeScalar
        for (int i = 0; i < newEnv.length - skipVariables; i++) {
            mv.visitInsn(Opcodes.DUP);
            mv.visitIntInsn(Opcodes.BIPUSH, i);
            String descriptor = EmitterMethodCreator.getVariableDescriptor(newEnv[i + skipVariables]);
            mv.visitLdcInsn(Type.getType(descriptor));
            mv.visitInsn(Opcodes.AASTORE);
        }
        // Stack: [Class, Class[]]

        // Use reflection to get the constructor
        // Note: Direct instantiation (NEW/INVOKESPECIAL) isn't possible because
        // the class name is only known at runtime
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/Class",
                "getConstructor",
                "([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;",
                false);
        // Stack: [Constructor]

        // Create array for constructor arguments (captured variable values)
        mv.visitIntInsn(Opcodes.BIPUSH, newEnv.length - skipVariables);
        mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");
        // Stack: [Constructor, Object[]]

        // Fill the arguments array with actual variable values from local variables
        for (Integer index : newSymbolTable.getAllVisibleVariables().keySet()) {
            if (index >= skipVariables) {
                String varName = newEnv[index];
                mv.visitInsn(Opcodes.DUP);
                mv.visitIntInsn(Opcodes.BIPUSH, index - skipVariables);
                mv.visitVarInsn(Opcodes.ALOAD, emitterVisitor.ctx.symbolTable.getVariableIndex(varName));
                mv.visitInsn(Opcodes.AASTORE);
                emitterVisitor.ctx.logDebug("Put variable " + emitterVisitor.ctx.symbolTable.getVariableIndex(varName) + " at parameter #" + (index - skipVariables) + " " + varName);
            }
        }
        // Stack: [Constructor, Object[]]

        // Create instance of the eval class with captured variables
        // This is where the "closure" behavior happens - the new instance
        // holds references to the captured variables
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/reflect/Constructor",
                "newInstance",
                "([Ljava/lang/Object;)Ljava/lang/Object;",
                false);
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Object");
        // Stack: [Object]

        // Convert the instance to a CODE reference
        // This wraps the instance in a RuntimeCode object that can be called
        mv.visitMethodInsn(
                Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/RuntimeCode",
                "makeCodeObject",
                "(Ljava/lang/Object;)Lorg/perlonjava/runtime/RuntimeScalar;",
                false);
        // Stack: [RuntimeScalar(Code)]

        // Push @_ (the current subroutine's arguments) for the eval to access
        mv.visitVarInsn(Opcodes.ALOAD, 1);
        // Stack: [RuntimeScalar(Code), RuntimeArray(@_)]

        // Push the calling context (scalar, list, or void)
        emitterVisitor.pushCallContext();
        // Stack: [RuntimeScalar(Code), RuntimeArray(@_), int]

        // Execute the eval code
        // The apply method runs the compiled code and returns the result
        mv.visitMethodInsn(
                Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/RuntimeCode",
                "apply",
                "(Lorg/perlonjava/runtime/RuntimeScalar;Lorg/perlonjava/runtime/RuntimeArray;I)Lorg/perlonjava/runtime/RuntimeList;",
                false);
        // Stack: [RuntimeList]

        // Convert result based on calling context
        if (emitterVisitor.ctx.contextType == RuntimeContextType.SCALAR) {
            // In scalar context, extract the first element
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "org/perlonjava/runtime/RuntimeList", "scalar", "()Lorg/perlonjava/runtime/RuntimeScalar;", false);
            // Stack: [RuntimeScalar]
        } else if (emitterVisitor.ctx.contextType == RuntimeContextType.VOID) {
            // In void context, discard the result
            mv.visitInsn(Opcodes.POP);
            // Stack: []
        }
        // In list context, leave the RuntimeList on the stack
    }
}