package org.perlonjava.backend.jvm;

import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.perlonjava.app.cli.CompilerOptions;
import org.perlonjava.frontend.astnode.EvalOperatorNode;
import org.perlonjava.frontend.astnode.OperatorNode;
import org.perlonjava.frontend.analysis.EmitterVisitor;
import org.perlonjava.runtime.runtimetypes.RuntimeArray;
import org.perlonjava.runtime.runtimetypes.RuntimeCode;
import org.perlonjava.runtime.runtimetypes.RuntimeContextType;
import org.perlonjava.frontend.semantic.ScopedSymbolTable;

/**
 * EmitEval handles the bytecode generation for Perl's eval operator.
 *
 * <h2>Overview</h2>
 * The eval operator in Perl compiles and executes a string at runtime. This implementation
 * generates bytecode that will:
 * <ol>
 *   <li>Capture the current lexical environment (closure variables)</li>
 *   <li>Compile the eval string into a new Java class at runtime</li>
 *   <li>Instantiate the class with captured variables</li>
 *   <li>Execute the compiled code</li>
 * </ol>
 *
 * <h2>Design Decisions</h2>
 * <ul>
 *   <li><b>Dynamic Class Generation:</b> Each eval creates a new class (e.g., anon5, anon6)
 *       because each eval may have different captured variables, even for identical strings</li>
 *   <li><b>EvalTag System:</b> A unique evalTag (e.g., "eval12") is generated at compile-time
 *       for each eval site. This tag links the runtime eval to its compile-time context</li>
 *   <li><b>Reflection for Instantiation:</b> We use Constructor.newInstance() rather than
 *       direct instantiation because class names are generated at runtime</li>
 *   <li><b>Global ClassLoader:</b> All eval classes use GlobalVariable.globalClassLoader
 *       to ensure they can reference each other and share the same namespace</li>
 * </ul>
 *
 * <h2>Performance Characteristics</h2>
 * <ul>
 *   <li>First execution of an eval string requires full compilation (slow)</li>
 *   <li>Repeated execution of identical eval strings in the same context uses cached classes (fast)</li>
 * </ul>
 *
 * <h2>Memory Considerations</h2>
 * Each eval creates a new class that remains loaded until the global class loader is reset.
 * Long-running applications that generate many unique eval strings should monitor memory usage.
 *
 */
public class EmitEval {
    /**
     * Handles the emission of bytecode for the Perl 'eval' operator.
     *
     * <h3>Bytecode Generation Flow</h3>
     * <pre>
     * 1. Push eval string onto stack
     * 2. Call evalStringHelper(string, evalTag) â†’ returns Class
     * 3. Create Class[] array of parameter types (for captured variables)
     * 4. Get constructor via reflection: class.getConstructor(paramTypes)
     * 5. Create Object[] array of captured variable values
     * 6. Instantiate: constructor.newInstance(args)
     * 7. Convert to CODE reference: makeCodeObject(instance)
     * 8. Execute: RuntimeCode.apply(code, @_, context)
     * </pre>
     *
     * <h3>Example Perl Code</h3>
     * <pre>
     * my $x = 10;
     * my $y = 20;
     * my $result = eval '$x + $y';  # Captures $x and $y
     * </pre>
     *
     * <h3>Generated Bytecode Pattern</h3>
     * The generated bytecode effectively does:
     * <pre>
     * Class clazz = RuntimeCode.evalStringHelper(evalString, "eval123");
     * Constructor ctor = clazz.getConstructor(new Class[]{RuntimeScalar.class, RuntimeScalar.class});
     * Object instance = ctor.newInstance(new Object[]{$x, $y});
     * RuntimeScalar code = RuntimeCode.makeCodeObject(instance);
     * RuntimeList result = RuntimeCode.apply(code, @_, wantarray);
     * </pre>
     *
     * @param emitterVisitor The visitor that traverses the AST
     * @param node           The OperatorNode representing the eval operation (contains the eval string expression)
     */
    static void handleEvalOperator(EmitterVisitor emitterVisitor, OperatorNode node) {
        EmitterContext ctx = emitterVisitor.ctx;
        MethodVisitor mv = ctx.mv;

        // Log current symbol table state for debugging
        emitterVisitor.ctx.logDebug("(eval) ctx.symbolTable.getAllVisibleVariables");

        // Capture the current lexical environment
        // This creates a snapshot of all variables visible at this eval site
        ScopedSymbolTable newSymbolTable = emitterVisitor.ctx.symbolTable.snapShot();
        if (node instanceof EvalOperatorNode evalOperatorNode) {
            // Preserve any special flags from the parse-time symbol table
            newSymbolTable.copyFlagsFrom(evalOperatorNode.getSymbolTable());
        }

        // Get list of all captured variable names
        String[] newEnv = newSymbolTable.getVariableNames();
        emitterVisitor.ctx.logDebug("evalStringHelper newSymbolTable: " + newSymbolTable);

        // Generate unique identifier for this eval site
        // This counter is incremented globally, ensuring each eval gets a unique tag
        int counter = EmitterMethodCreator.classCounter++;

        // Create compiler options specific to this eval
        // The filename becomes "(eval N)" for better error messages
        CompilerOptions compilerOptions = emitterVisitor.ctx.compilerOptions.clone();
        compilerOptions.fileName = "(eval " + counter + ")";

        // The evalTag is crucial - it links the runtime eval to this compile-time context
        // When evalStringHelper is called at runtime, it uses this tag to retrieve
        // the saved EmitterContext with the correct symbol table and compiler options
        String evalTag = "eval" + counter;

        // Create and save the EmitterContext for this eval
        // This context will be retrieved at runtime when the eval string is compiled
        EmitterContext evalCtx = new EmitterContext(
                null, // Java class name will be generated at runtime
                newSymbolTable,
                null, // method visitor not needed yet
                null, // class writer not needed yet
                emitterVisitor.ctx.contextType,
                true, // is boxed
                emitterVisitor.ctx.errorUtil,
                compilerOptions,
                new RuntimeArray());

        // Store the captured environment array in the context
        // This ensures runtime uses the exact same array structure as compile-time
        evalCtx.capturedEnv = newEnv;
        
        // Mark if this is evalbytes - needed to prevent Unicode source detection
        evalCtx.isEvalbytes = node.operator.equals("evalbytes");

        // Store the context in a static map, indexed by evalTag
        // This allows the runtime compilation to access the compile-time environment
        RuntimeCode.evalContext.put(evalTag, evalCtx);

        // Generate bytecode to evaluate the eval string expression
        // This pushes the string value onto the stack
        node.operand.accept(emitterVisitor.with(RuntimeContextType.SCALAR));
        // Stack: [RuntimeScalar(String)]

        // Perl clears $@ at entry to eval/evalbytes, before compilation/execution.
        mv.visitLdcInsn("main::@");
        mv.visitLdcInsn("");
        mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/runtimetypes/GlobalVariable",
                "setGlobalVariable",
                "(Ljava/lang/String;Ljava/lang/String;)V", false);

        if (node.operator.equals("evalbytes")) {
            // For evalbytes, verify the string contains valid bytes
            ctx.mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(
                    Opcodes.INVOKESTATIC,
                    "org/perlonjava/runtime/runtimetypes/ScalarUtils",
                    "assertBytes",
                    "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;)V",
                    false);
        }

        // Wrap the runtime compile/instantiate/apply path so eval catches syntax errors
        // thrown by RuntimeCode.evalStringHelper() (and any reflection errors).
        Label tryStart = new Label();
        Label tryEnd = new Label();
        Label catchBlock = new Label();
        Label endCatch = new Label();
        mv.visitTryCatchBlock(tryStart, tryEnd, catchBlock, "java/lang/Throwable");
        mv.visitLabel(tryStart);

        // Calculate how many variables need to be passed
        // We skip 'this', '@_', and 'wantarray' which are handled separately
        int skipVariables = EmitterMethodCreator.skipVariables;

        // Check at COMPILE TIME if we should use interpreter for eval STRING
        if (RuntimeCode.EVAL_USE_INTERPRETER) {
            // INTERPRETER PATH: Compile to InterpretedCode and execute directly
            emitEvalInterpreterPath(emitterVisitor, evalTag, newEnv, newSymbolTable, skipVariables);
        } else {
            // COMPILER PATH: Use reflection to compile and instantiate (current behavior)
            emitEvalCompilerPath(emitterVisitor, evalTag, newEnv, newSymbolTable, skipVariables);
        }

        mv.visitLabel(tryEnd);
        mv.visitJumpInsn(Opcodes.GOTO, endCatch);

        // Catch any exception from evalStringHelper / reflection / applyEval
        mv.visitLabel(catchBlock);
        mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/operators/WarnDie",
                "catchEval",
                "(Ljava/lang/Throwable;)Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;",
                false);
        mv.visitInsn(Opcodes.POP);
        if (emitterVisitor.ctx.contextType == RuntimeContextType.LIST) {
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "()V", false);
        } else {
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
            mv.visitInsn(Opcodes.DUP);
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeScalar");
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeScalar", "<init>", "()V", false);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;)V", false);
        }

        int evalResultSlot = emitterVisitor.ctx.symbolTable.allocateLocalVariable();
        mv.visitLabel(endCatch);
        mv.visitVarInsn(Opcodes.ASTORE, evalResultSlot);

        // If eval returned a non-local control flow marker (next/last/redo),
        // it must apply to the enclosing scope, matching Perl semantics.
        // We translate it into a local jump to the appropriate loop/block label.
        Label evalNoControlFlow = new Label();
        Label evalNotNextLastRedo = new Label();
        mv.visitVarInsn(Opcodes.ALOAD, evalResultSlot);
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                "org/perlonjava/runtime/runtimetypes/RuntimeList",
                "isNonLocalGoto",
                "()Z",
                false);
        mv.visitJumpInsn(Opcodes.IFEQ, evalNoControlFlow);

        mv.visitVarInsn(Opcodes.ALOAD, evalResultSlot);

        int cfSlot = emitterVisitor.ctx.symbolTable.allocateLocalVariable();
        mv.visitTypeInsn(Opcodes.CHECKCAST, "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowList");
        mv.visitVarInsn(Opcodes.ASTORE, cfSlot);

        // Load label (may be null)
        int labelSlot = emitterVisitor.ctx.symbolTable.allocateLocalVariable();
        mv.visitVarInsn(Opcodes.ALOAD, cfSlot);
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowList",
                "getControlFlowLabel",
                "()Ljava/lang/String;",
                false);
        mv.visitVarInsn(Opcodes.ASTORE, labelSlot);

        // Load type ordinal
        int typeSlot = emitterVisitor.ctx.symbolTable.allocateLocalVariable();
        mv.visitVarInsn(Opcodes.ALOAD, cfSlot);
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowList",
                "getControlFlowType",
                "()Lorg/perlonjava/runtime/runtimetypes/ControlFlowType;",
                false);
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                "org/perlonjava/runtime/runtimetypes/ControlFlowType",
                "ordinal",
                "()I",
                false);
        mv.visitVarInsn(Opcodes.ISTORE, typeSlot);

        // If this is not NEXT/LAST/REDO (ordinals 0..2), treat it as an eval error.
        // In particular, bad goto inside eval must set $@ and return undef/empty list,
        // and must NOT escape as a marked RuntimeList (which would terminate the script).
        Label evalIsNextLastRedo = new Label();
        mv.visitVarInsn(Opcodes.ILOAD, typeSlot);
        mv.visitInsn(Opcodes.ICONST_2);
        mv.visitJumpInsn(Opcodes.IF_ICMPLE, evalIsNextLastRedo);

        // Set $@ = marker.buildErrorMessage()
        mv.visitLdcInsn("main::@");
        mv.visitVarInsn(Opcodes.ALOAD, cfSlot);
        mv.visitFieldInsn(Opcodes.GETFIELD,
                "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowList",
                "marker",
                "Lorg/perlonjava/runtime/runtimetypes/ControlFlowMarker;");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                "org/perlonjava/runtime/runtimetypes/ControlFlowMarker",
                "buildErrorMessage",
                "()Ljava/lang/String;",
                false);
        mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/runtimetypes/GlobalVariable",
                "setGlobalVariable",
                "(Ljava/lang/String;Ljava/lang/String;)V",
                false);

        // Return undef/empty list from eval on error
        if (emitterVisitor.ctx.contextType == RuntimeContextType.LIST) {
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "()V", false);
        } else {
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
            mv.visitInsn(Opcodes.DUP);
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeScalar");
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeScalar", "<init>", "()V", false);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;)V", false);
        }
        mv.visitVarInsn(Opcodes.ASTORE, evalResultSlot);
        mv.visitJumpInsn(Opcodes.GOTO, evalNoControlFlow);

        mv.visitLabel(evalIsNextLastRedo);

        // 1) Labeled control flow: compare against each enclosing loop/block label
        Label checkUnlabeled = new Label();
        mv.visitVarInsn(Opcodes.ALOAD, labelSlot);
        mv.visitJumpInsn(Opcodes.IFNULL, checkUnlabeled);

        for (LoopLabels loopLabels : emitterVisitor.ctx.javaClassInfo.loopLabelStack) {
            if (loopLabels != null && loopLabels.labelName != null) {
                Label nextLabel = new Label();
                mv.visitVarInsn(Opcodes.ALOAD, labelSlot);
                mv.visitLdcInsn(loopLabels.labelName);
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                        "java/lang/String",
                        "equals",
                        "(Ljava/lang/Object;)Z",
                        false);
                mv.visitJumpInsn(Opcodes.IFEQ, nextLabel);

                // Matched label: jump based on type (0=LAST,1=NEXT,2=REDO)
                Label isLast = new Label();
                Label isNext = new Label();
                Label isRedo = new Label();
                mv.visitVarInsn(Opcodes.ILOAD, typeSlot);
                mv.visitInsn(Opcodes.ICONST_0);
                mv.visitJumpInsn(Opcodes.IF_ICMPEQ, isLast);
                mv.visitVarInsn(Opcodes.ILOAD, typeSlot);
                mv.visitInsn(Opcodes.ICONST_1);
                mv.visitJumpInsn(Opcodes.IF_ICMPEQ, isNext);
                mv.visitVarInsn(Opcodes.ILOAD, typeSlot);
                mv.visitInsn(Opcodes.ICONST_2);
                mv.visitJumpInsn(Opcodes.IF_ICMPEQ, isRedo);

                // Other types are not handled here
                mv.visitJumpInsn(Opcodes.GOTO, nextLabel);

                mv.visitLabel(isLast);
                mv.visitJumpInsn(Opcodes.GOTO, loopLabels.lastLabel);

                mv.visitLabel(isNext);
                mv.visitJumpInsn(Opcodes.GOTO, loopLabels.nextLabel);

                mv.visitLabel(isRedo);
                mv.visitJumpInsn(Opcodes.GOTO, loopLabels.redoLabel);

                mv.visitLabel(nextLabel);
            }
        }

        // No labeled target matched: throw the marker's error
        mv.visitLdcInsn("main::@");
        mv.visitVarInsn(Opcodes.ALOAD, cfSlot);
        mv.visitFieldInsn(Opcodes.GETFIELD,
                "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowList",
                "marker",
                "Lorg/perlonjava/runtime/runtimetypes/ControlFlowMarker;");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                "org/perlonjava/runtime/runtimetypes/ControlFlowMarker",
                "buildErrorMessage",
                "()Ljava/lang/String;",
                false);
        mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/runtimetypes/GlobalVariable",
                "setGlobalVariable",
                "(Ljava/lang/String;Ljava/lang/String;)V",
                false);
        // Return undef/empty list from eval on error
        if (emitterVisitor.ctx.contextType == RuntimeContextType.LIST) {
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "()V", false);
        } else {
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
            mv.visitInsn(Opcodes.DUP);
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeScalar");
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeScalar", "<init>", "()V", false);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;)V", false);
        }
        mv.visitVarInsn(Opcodes.ASTORE, evalResultSlot);
        mv.visitJumpInsn(Opcodes.GOTO, evalNoControlFlow);

        // 2) Unlabeled control flow: target the innermost true loop
        mv.visitLabel(checkUnlabeled);
        LoopLabels unlabeledTarget = emitterVisitor.ctx.javaClassInfo.findInnermostTrueLoopLabels();
        if (unlabeledTarget != null) {
            Label isLast = new Label();
            Label isNext = new Label();
            Label isRedo = new Label();
            mv.visitVarInsn(Opcodes.ILOAD, typeSlot);
            mv.visitInsn(Opcodes.ICONST_0);
            mv.visitJumpInsn(Opcodes.IF_ICMPEQ, isLast);
            mv.visitVarInsn(Opcodes.ILOAD, typeSlot);
            mv.visitInsn(Opcodes.ICONST_1);
            mv.visitJumpInsn(Opcodes.IF_ICMPEQ, isNext);
            mv.visitVarInsn(Opcodes.ILOAD, typeSlot);
            mv.visitInsn(Opcodes.ICONST_2);
            mv.visitJumpInsn(Opcodes.IF_ICMPEQ, isRedo);
            // Any other control flow type was filtered out earlier; fall through.
            mv.visitJumpInsn(Opcodes.GOTO, evalNotNextLastRedo);

            mv.visitLabel(isLast);
            mv.visitVarInsn(Opcodes.ALOAD, cfSlot);
            mv.visitFieldInsn(Opcodes.GETFIELD,
                    "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowList",
                    "marker",
                    "Lorg/perlonjava/runtime/runtimetypes/ControlFlowMarker;");
            mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                    "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowRegistry",
                    "register",
                    "(Lorg/perlonjava/runtime/runtimetypes/ControlFlowMarker;)V",
                    false);

            // Return undef/empty list from eval after registering control flow
            if (emitterVisitor.ctx.contextType == RuntimeContextType.LIST) {
                mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
                mv.visitInsn(Opcodes.DUP);
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "()V", false);
            } else {
                mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
                mv.visitInsn(Opcodes.DUP);
                mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeScalar");
                mv.visitInsn(Opcodes.DUP);
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeScalar", "<init>", "()V", false);
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;)V", false);
            }
            mv.visitVarInsn(Opcodes.ASTORE, evalResultSlot);
            mv.visitJumpInsn(Opcodes.GOTO, evalNoControlFlow);

            mv.visitLabel(isNext);
            mv.visitVarInsn(Opcodes.ALOAD, cfSlot);
            mv.visitFieldInsn(Opcodes.GETFIELD,
                    "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowList",
                    "marker",
                    "Lorg/perlonjava/runtime/runtimetypes/ControlFlowMarker;");
            mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                    "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowRegistry",
                    "register",
                    "(Lorg/perlonjava/runtime/runtimetypes/ControlFlowMarker;)V",
                    false);

            // Return undef/empty list from eval after registering control flow
            if (emitterVisitor.ctx.contextType == RuntimeContextType.LIST) {
                mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
                mv.visitInsn(Opcodes.DUP);
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "()V", false);
            } else {
                mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
                mv.visitInsn(Opcodes.DUP);
                mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeScalar");
                mv.visitInsn(Opcodes.DUP);
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeScalar", "<init>", "()V", false);
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;)V", false);
            }
            mv.visitVarInsn(Opcodes.ASTORE, evalResultSlot);
            mv.visitJumpInsn(Opcodes.GOTO, evalNoControlFlow);

            mv.visitLabel(isRedo);
            mv.visitJumpInsn(Opcodes.GOTO, unlabeledTarget.redoLabel);
        } else {
            // next/last/redo outside any loop
            mv.visitLdcInsn("main::@");
            mv.visitVarInsn(Opcodes.ALOAD, cfSlot);
            mv.visitFieldInsn(Opcodes.GETFIELD,
                    "org/perlonjava/runtime/runtimetypes/RuntimeControlFlowList",
                    "marker",
                    "Lorg/perlonjava/runtime/runtimetypes/ControlFlowMarker;");
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                    "org/perlonjava/runtime/runtimetypes/ControlFlowMarker",
                    "buildErrorMessage",
                    "()Ljava/lang/String;",
                    false);
            mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                    "org/perlonjava/runtime/runtimetypes/GlobalVariable",
                    "setGlobalVariable",
                    "(Ljava/lang/String;Ljava/lang/String;)V",
                    false);
            // Return undef/empty list from eval on error
            if (emitterVisitor.ctx.contextType == RuntimeContextType.LIST) {
                mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
                mv.visitInsn(Opcodes.DUP);
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "()V", false);
            } else {
                mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
                mv.visitInsn(Opcodes.DUP);
                mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeScalar");
                mv.visitInsn(Opcodes.DUP);
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeScalar", "<init>", "()V", false);
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;)V", false);
            }
            mv.visitVarInsn(Opcodes.ASTORE, evalResultSlot);
            mv.visitJumpInsn(Opcodes.GOTO, evalNoControlFlow);
        }

        // Fallthrough for non NEXT/LAST/REDO control flow markers is handled above as an eval error.
        mv.visitLabel(evalNotNextLastRedo);
        mv.visitVarInsn(Opcodes.ALOAD, cfSlot);

        mv.visitVarInsn(Opcodes.ASTORE, evalResultSlot);

        mv.visitLabel(evalNoControlFlow);

        mv.visitVarInsn(Opcodes.ALOAD, evalResultSlot);

        // Convert result based on calling context
        if (emitterVisitor.ctx.contextType == RuntimeContextType.SCALAR) {
            // In scalar context, extract the first element
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "scalar", "()Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;", false);
            // Stack: [RuntimeScalar]
        } else if (emitterVisitor.ctx.contextType == RuntimeContextType.VOID) {
            // In void context, discard the result
            mv.visitInsn(Opcodes.POP);
            // Stack: []
        }
        // In list context, leave the RuntimeList on the stack
    }

    /**
     * Emit bytecode for the interpreter path: compile to InterpretedCode and execute directly.
     * This path is used when JPERL_EVAL_USE_INTERPRETER is set.
     *
     * @param emitterVisitor The visitor that traverses the AST
     * @param evalTag The unique identifier for this eval site
     * @param newEnv The captured environment variable names
     * @param newSymbolTable The symbol table with captured variables
     * @param skipVariables Number of reserved variables to skip (this, @_, wantarray)
     */
    private static void emitEvalInterpreterPath(EmitterVisitor emitterVisitor, String evalTag,
                                                String[] newEnv, ScopedSymbolTable newSymbolTable,
                                                int skipVariables) {
        MethodVisitor mv = emitterVisitor.ctx.mv;

        // Stack: [RuntimeScalar(String)]

        // Push the evalTag
        mv.visitLdcInsn(evalTag);
        // Stack: [RuntimeScalar(String), String]

        // Build array of runtime values for captured variables
        mv.visitIntInsn(Opcodes.BIPUSH, newEnv.length - skipVariables);
        mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");
        // Stack: [RuntimeScalar(String), String, Object[]]

        // Fill the runtime values array with actual variable values from local variables
        // IMPORTANT: Fill in capturedEnv index order so runtimeValues[] matches newEnv[] ordering.
        // Iterating a Map keySet() is not guaranteed to be deterministic and can break
        // lexical capture across nested eval boundaries.
        for (int index = skipVariables; index < newEnv.length; index++) {
            String varName = newEnv[index];
            if (varName == null) {
                continue;
            }
            mv.visitInsn(Opcodes.DUP);
            mv.visitIntInsn(Opcodes.BIPUSH, index - skipVariables);
            mv.visitVarInsn(Opcodes.ALOAD, emitterVisitor.ctx.symbolTable.getVariableIndex(varName));
            mv.visitInsn(Opcodes.AASTORE);
        }
        // Stack: [RuntimeScalar(String), String, Object[]]

        // Push @_ (the current subroutine's arguments)
        mv.visitVarInsn(Opcodes.ALOAD, 1);
        // Stack: [RuntimeScalar(String), String, Object[], RuntimeArray(@_)]

        // Push the calling context (scalar, list, or void)
        // For eval, use the context determined by how the eval result is used
        // This matches the compiler path which uses a compile-time constant
        if (emitterVisitor.ctx.contextType == RuntimeContextType.RUNTIME) {
            // If context is RUNTIME, load it from wantarray variable
            mv.visitVarInsn(Opcodes.ILOAD, emitterVisitor.ctx.symbolTable.getVariableIndex("wantarray"));
        } else {
            // Otherwise use the compile-time constant (LIST/SCALAR/VOID)
            mv.visitLdcInsn(emitterVisitor.ctx.contextType);
        }
        // Stack: [RuntimeScalar(String), String, Object[], RuntimeArray(@_), int]

        // Call evalStringWithInterpreter which returns RuntimeList directly
        mv.visitMethodInsn(
                Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/runtimetypes/RuntimeCode",
                "evalStringWithInterpreter",
                "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;Ljava/lang/String;[Ljava/lang/Object;Lorg/perlonjava/runtime/runtimetypes/RuntimeArray;I)Lorg/perlonjava/runtime/runtimetypes/RuntimeList;",
                false);
        // Stack: [RuntimeList]
    }

    /**
     * Emit bytecode for the compiler path: use reflection to compile and instantiate.
     * This is the traditional path using JVM bytecode compilation.
     *
     * @param emitterVisitor The visitor that traverses the AST
     * @param evalTag The unique identifier for this eval site
     * @param newEnv The captured environment variable names
     * @param newSymbolTable The symbol table with captured variables
     * @param skipVariables Number of reserved variables to skip (this, @_, wantarray)
     */
    private static void emitEvalCompilerPath(EmitterVisitor emitterVisitor, String evalTag,
                                            String[] newEnv, ScopedSymbolTable newSymbolTable,
                                            int skipVariables) {
        MethodVisitor mv = emitterVisitor.ctx.mv;

        // Stack: [RuntimeScalar(String)]

        // Push the evalTag that links to the saved context
        mv.visitLdcInsn(evalTag);
        // Stack: [RuntimeScalar(String), String]

        // Build array of runtime values for captured variables
        // These are passed to evalStringHelper so BEGIN blocks can access outer lexical variables
        mv.visitIntInsn(Opcodes.BIPUSH, newEnv.length - skipVariables);
        mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");
        // Stack: [RuntimeScalar(String), String, Object[]]

        // Fill the runtime values array with actual variable values from local variables
        for (Integer index : newSymbolTable.getAllVisibleVariables().keySet()) {
            if (index >= skipVariables) {
                String varName = newEnv[index];
                mv.visitInsn(Opcodes.DUP);
                mv.visitIntInsn(Opcodes.BIPUSH, index - skipVariables);
                mv.visitVarInsn(Opcodes.ALOAD, emitterVisitor.ctx.symbolTable.getVariableIndex(varName));
                mv.visitInsn(Opcodes.AASTORE);
            }
        }
        // Stack: [RuntimeScalar(String), String, Object[]]

        // Call evalStringHelper to compile the eval string at runtime
        // Now passes runtime values so BEGIN blocks can access outer lexical variables
        mv.visitMethodInsn(
                Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/runtimetypes/RuntimeCode",
                "evalStringHelper",
                "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/Class;",
                false);
        // Stack: [Class or null]

        // Check if evalStringHelper returned null (compilation error)
        Label compileSuccess = new Label();
        Label compileEnd = new Label();
        mv.visitInsn(Opcodes.DUP);
        mv.visitJumpInsn(Opcodes.IFNONNULL, compileSuccess);
        // Stack: [null]

        // Compilation failed, $SIG{__DIE__} was called, $@ is set
        // Pop null and return undef
        mv.visitInsn(Opcodes.POP);
        // Stack: []

        // Create undef result
        if (emitterVisitor.ctx.contextType == RuntimeContextType.LIST) {
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "()V", false);
        } else {
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeList");
            mv.visitInsn(Opcodes.DUP);
            mv.visitTypeInsn(Opcodes.NEW, "org/perlonjava/runtime/runtimetypes/RuntimeScalar");
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeScalar", "<init>", "()V", false);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "org/perlonjava/runtime/runtimetypes/RuntimeList", "<init>", "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;)V", false);
        }
        mv.visitJumpInsn(Opcodes.GOTO, compileEnd);
        // Stack: [RuntimeList]

        mv.visitLabel(compileSuccess);
        // Stack: [Class]

        // Create array of parameter types for the constructor
        // Each captured variable becomes a constructor parameter (including null gaps)
        mv.visitIntInsn(Opcodes.BIPUSH, newEnv.length - skipVariables);
        mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Class");
        // Stack: [Class, Class[]]

        // Fill the parameter types array based on variable types
        // Variables starting with @ are RuntimeArray, % are RuntimeHash, others are RuntimeScalar
        // getVariableDescriptor handles nulls gracefully (returns RuntimeScalar descriptor)
        for (int i = 0; i < newEnv.length - skipVariables; i++) {
            mv.visitInsn(Opcodes.DUP);
            mv.visitIntInsn(Opcodes.BIPUSH, i);
            String descriptor = EmitterMethodCreator.getVariableDescriptor(newEnv[i + skipVariables]);
            mv.visitLdcInsn(Type.getType(descriptor));
            mv.visitInsn(Opcodes.AASTORE);
        }
        // Stack: [Class, Class[]]

        // Use reflection to get the constructor
        // Note: Direct instantiation (NEW/INVOKESPECIAL) isn't possible because
        // the class name is only known at runtime
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/Class",
                "getConstructor",
                "([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;",
                false);
        // Stack: [Constructor]

        // Create array for constructor arguments (captured variable values)
        mv.visitIntInsn(Opcodes.BIPUSH, newEnv.length - skipVariables);
        mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");
        // Stack: [Constructor, Object[]]

        // Fill the arguments array with actual variable values from local variables
        for (Integer index : newSymbolTable.getAllVisibleVariables().keySet()) {
            if (index >= skipVariables) {
                String varName = newEnv[index];
                mv.visitInsn(Opcodes.DUP);
                mv.visitIntInsn(Opcodes.BIPUSH, index - skipVariables);
                mv.visitVarInsn(Opcodes.ALOAD, emitterVisitor.ctx.symbolTable.getVariableIndex(varName));
                mv.visitInsn(Opcodes.AASTORE);
                emitterVisitor.ctx.logDebug("Put variable " + emitterVisitor.ctx.symbolTable.getVariableIndex(varName) + " at parameter #" + (index - skipVariables) + " " + varName);
            }
        }
        // Stack: [Constructor, Object[]]

        // Create instance of the eval class with captured variables
        // This is where the "closure" behavior happens - the new instance
        // holds references to the captured variables
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/reflect/Constructor",
                "newInstance",
                "([Ljava/lang/Object;)Ljava/lang/Object;",
                false);
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Object");
        // Stack: [Object]

        // Convert the instance to a CODE reference
        // This wraps the instance in a RuntimeCode object that can be called
        mv.visitMethodInsn(
                Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/runtimetypes/RuntimeCode",
                "makeCodeObject",
                "(Ljava/lang/Object;)Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;",
                false);
        // Stack: [RuntimeScalar(Code)]

        // Push @_ (the current subroutine's arguments) for the eval to access
        mv.visitVarInsn(Opcodes.ALOAD, 1);
        // Stack: [RuntimeScalar(Code), RuntimeArray(@_)]

        // Push the calling context (scalar, list, or void)
        emitterVisitor.pushCallContext();
        // Stack: [RuntimeScalar(Code), RuntimeArray(@_), int]

        // Execute the eval code
        // The apply method runs the compiled code and returns the result
        mv.visitMethodInsn(
                Opcodes.INVOKESTATIC,
                "org/perlonjava/runtime/runtimetypes/RuntimeCode",
                "applyEval",
                "(Lorg/perlonjava/runtime/runtimetypes/RuntimeScalar;Lorg/perlonjava/runtime/runtimetypes/RuntimeArray;I)Lorg/perlonjava/runtime/runtimetypes/RuntimeList;",
                false);
        // Stack: [RuntimeList]

        // Both success and failure paths converge here with RuntimeList on stack
        mv.visitLabel(compileEnd);
    }
}