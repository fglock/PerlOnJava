package org.perlonjava.backend.bytecode;

import org.perlonjava.runtime.runtimetypes.RuntimeBase;
import org.perlonjava.runtime.runtimetypes.RuntimeScalar;
import org.perlonjava.runtime.operators.BitwiseOperators;
import org.perlonjava.runtime.operators.Directory;
import org.perlonjava.runtime.operators.IOOperator;
import org.perlonjava.runtime.operators.MathOperators;
import org.perlonjava.runtime.operators.Random;
import org.perlonjava.runtime.operators.ScalarOperators;
import org.perlonjava.runtime.operators.StringOperators;
import org.perlonjava.runtime.operators.Time;
import org.perlonjava.runtime.operators.WarnDie;

/**
 * Handler for scalar unary operations (chr, ord, abs, sin, cos, lc, uc, etc.)
 * Generated by dev/tools/generate_opcode_handlers.pl
 * DO NOT EDIT MANUALLY - regenerate using the tool
 */
public class ScalarUnaryOpcodeHandler {

    /**
     * Execute scalar unary operations (chr, ord, abs, sin, cos, lc, uc, etc.) operation.
     */
    public static int execute(int opcode, short[] bytecode, int pc,
                              RuntimeBase[] registers) {
        // Read registers (shared by all opcodes in this group)
        int rd = bytecode[pc++];
        int rs = bytecode[pc++];

        // Dispatch based on specific opcode
        registers[rd] = switch (opcode) {
            case Opcodes.INT -> MathOperators.integer((RuntimeScalar) registers[rs]);
            case Opcodes.LOG -> MathOperators.log((RuntimeScalar) registers[rs]);
            case Opcodes.SQRT -> MathOperators.sqrt((RuntimeScalar) registers[rs]);
            case Opcodes.COS -> MathOperators.cos((RuntimeScalar) registers[rs]);
            case Opcodes.SIN -> MathOperators.sin((RuntimeScalar) registers[rs]);
            case Opcodes.EXP -> MathOperators.exp((RuntimeScalar) registers[rs]);
            case Opcodes.ABS -> MathOperators.abs((RuntimeScalar) registers[rs]);
            case Opcodes.BINARY_NOT -> BitwiseOperators.bitwiseNotBinary((RuntimeScalar) registers[rs]);
            case Opcodes.INTEGER_BITWISE_NOT -> BitwiseOperators.integerBitwiseNot((RuntimeScalar) registers[rs]);
            case Opcodes.ORD -> ScalarOperators.ord((RuntimeScalar) registers[rs]);
            case Opcodes.ORD_BYTES -> ScalarOperators.ordBytes((RuntimeScalar) registers[rs]);
            case Opcodes.OCT -> ScalarOperators.oct((RuntimeScalar) registers[rs]);
            case Opcodes.HEX -> ScalarOperators.hex((RuntimeScalar) registers[rs]);
            case Opcodes.SRAND -> Random.srand((RuntimeScalar) registers[rs]);
            case Opcodes.CHR -> StringOperators.chr((RuntimeScalar) registers[rs]);
            case Opcodes.CHR_BYTES -> StringOperators.chrBytes((RuntimeScalar) registers[rs]);
            case Opcodes.LENGTH_BYTES -> StringOperators.lengthBytes((RuntimeScalar) registers[rs]);
            case Opcodes.QUOTEMETA -> StringOperators.quotemeta((RuntimeScalar) registers[rs]);
            case Opcodes.FC -> StringOperators.fc((RuntimeScalar) registers[rs]);
            case Opcodes.LC -> StringOperators.lc((RuntimeScalar) registers[rs]);
            case Opcodes.LCFIRST -> StringOperators.lcfirst((RuntimeScalar) registers[rs]);
            case Opcodes.UC -> StringOperators.uc((RuntimeScalar) registers[rs]);
            case Opcodes.UCFIRST -> StringOperators.ucfirst((RuntimeScalar) registers[rs]);
            case Opcodes.SLEEP -> Time.sleep((RuntimeScalar) registers[rs]);
            case Opcodes.TELL -> IOOperator.tell((RuntimeScalar) registers[rs]);
            case Opcodes.RMDIR -> Directory.rmdir((RuntimeScalar) registers[rs]);
            case Opcodes.CLOSEDIR -> Directory.closedir((RuntimeScalar) registers[rs]);
            case Opcodes.REWINDDIR -> Directory.rewinddir((RuntimeScalar) registers[rs]);
            case Opcodes.TELLDIR -> Directory.telldir((RuntimeScalar) registers[rs]);
            case Opcodes.CHDIR -> Directory.chdir((RuntimeScalar) registers[rs]);
            case Opcodes.EXIT -> WarnDie.exit((RuntimeScalar) registers[rs]);
            default -> throw new IllegalStateException("Unknown opcode in ScalarUnaryOpcodeHandler: " + opcode);
        };

        return pc;
    }

    /**
     * Disassemble scalar unary operations (chr, ord, abs, sin, cos, lc, uc, etc.) operation.
     */
    public static int disassemble(int opcode, short[] bytecode, int pc,
                                   StringBuilder sb) {
        int rd = bytecode[pc++];
        int rs = bytecode[pc++];

        switch (opcode) {
            case Opcodes.INT -> sb.append("INT r").append(rd).append(" = int(r").append(rs).append(")\n");
            case Opcodes.LOG -> sb.append("LOG r").append(rd).append(" = log(r").append(rs).append(")\n");
            case Opcodes.SQRT -> sb.append("SQRT r").append(rd).append(" = sqrt(r").append(rs).append(")\n");
            case Opcodes.COS -> sb.append("COS r").append(rd).append(" = cos(r").append(rs).append(")\n");
            case Opcodes.SIN -> sb.append("SIN r").append(rd).append(" = sin(r").append(rs).append(")\n");
            case Opcodes.EXP -> sb.append("EXP r").append(rd).append(" = exp(r").append(rs).append(")\n");
            case Opcodes.ABS -> sb.append("ABS r").append(rd).append(" = abs(r").append(rs).append(")\n");
            case Opcodes.BINARY_NOT -> sb.append("BINARY_NOT r").append(rd).append(" = binary~(r").append(rs).append(")\n");
            case Opcodes.INTEGER_BITWISE_NOT -> sb.append("INTEGER_BITWISE_NOT r").append(rd).append(" = integerBitwiseNot(r").append(rs).append(")\n");
            case Opcodes.ORD -> sb.append("ORD r").append(rd).append(" = ord(r").append(rs).append(")\n");
            case Opcodes.ORD_BYTES -> sb.append("ORD_BYTES r").append(rd).append(" = ordBytes(r").append(rs).append(")\n");
            case Opcodes.OCT -> sb.append("OCT r").append(rd).append(" = oct(r").append(rs).append(")\n");
            case Opcodes.HEX -> sb.append("HEX r").append(rd).append(" = hex(r").append(rs).append(")\n");
            case Opcodes.SRAND -> sb.append("SRAND r").append(rd).append(" = srand(r").append(rs).append(")\n");
            case Opcodes.CHR -> sb.append("CHR r").append(rd).append(" = chr(r").append(rs).append(")\n");
            case Opcodes.CHR_BYTES -> sb.append("CHR_BYTES r").append(rd).append(" = chrBytes(r").append(rs).append(")\n");
            case Opcodes.LENGTH_BYTES -> sb.append("LENGTH_BYTES r").append(rd).append(" = lengthBytes(r").append(rs).append(")\n");
            case Opcodes.QUOTEMETA -> sb.append("QUOTEMETA r").append(rd).append(" = quotemeta(r").append(rs).append(")\n");
            case Opcodes.FC -> sb.append("FC r").append(rd).append(" = fc(r").append(rs).append(")\n");
            case Opcodes.LC -> sb.append("LC r").append(rd).append(" = lc(r").append(rs).append(")\n");
            case Opcodes.LCFIRST -> sb.append("LCFIRST r").append(rd).append(" = lcfirst(r").append(rs).append(")\n");
            case Opcodes.UC -> sb.append("UC r").append(rd).append(" = uc(r").append(rs).append(")\n");
            case Opcodes.UCFIRST -> sb.append("UCFIRST r").append(rd).append(" = ucfirst(r").append(rs).append(")\n");
            case Opcodes.SLEEP -> sb.append("SLEEP r").append(rd).append(" = sleep(r").append(rs).append(")\n");
            case Opcodes.TELL -> sb.append("TELL r").append(rd).append(" = tell(r").append(rs).append(")\n");
            case Opcodes.RMDIR -> sb.append("RMDIR r").append(rd).append(" = rmdir(r").append(rs).append(")\n");
            case Opcodes.CLOSEDIR -> sb.append("CLOSEDIR r").append(rd).append(" = closedir(r").append(rs).append(")\n");
            case Opcodes.REWINDDIR -> sb.append("REWINDDIR r").append(rd).append(" = rewinddir(r").append(rs).append(")\n");
            case Opcodes.TELLDIR -> sb.append("TELLDIR r").append(rd).append(" = telldir(r").append(rs).append(")\n");
            case Opcodes.CHDIR -> sb.append("CHDIR r").append(rd).append(" = chdir(r").append(rs).append(")\n");
            case Opcodes.EXIT -> sb.append("EXIT r").append(rd).append(" = exit(r").append(rs).append(")\n");
            default -> sb.append("UNKNOWN_").append(opcode).append("\n");
        }

        return pc;
    }
}
