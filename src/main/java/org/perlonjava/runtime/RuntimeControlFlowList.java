package org.perlonjava.runtime;

/**
 * A specialized RuntimeList that carries control flow information.
 * This is returned by control flow statements (last/next/redo/goto/goto &NAME)
 * to signal non-local control flow across subroutine boundaries.
 */
public class RuntimeControlFlowList extends RuntimeList {
    // Debug flag - set to true to enable detailed tracing
    private static final boolean DEBUG_TAILCALL = false;
    
    /** The control flow marker with type and label/codeRef information */
    public final ControlFlowMarker marker;
    
    /**
     * Constructor for control flow (last/next/redo/goto).
     * 
     * @param type The control flow type
     * @param label The label to jump to (null for unlabeled)
     * @param fileName Source file name (for error messages)
     * @param lineNumber Line number (for error messages)
     */
    public RuntimeControlFlowList(ControlFlowType type, String label, String fileName, int lineNumber) {
        super();
        this.marker = new ControlFlowMarker(type, label, fileName, lineNumber);
        if (DEBUG_TAILCALL) {
            System.err.println("[DEBUG-0a] RuntimeControlFlowList constructor (type,label): type=" + type + 
                              ", label=" + label + " @ " + fileName + ":" + lineNumber);
        }
    }
    
    /**
     * Constructor for tail call (goto &NAME).
     * 
     * @param codeRef The code reference to call
     * @param args The arguments to pass
     * @param fileName Source file name (for error messages)
     * @param lineNumber Line number (for error messages)
     */
    public RuntimeControlFlowList(RuntimeScalar codeRef, RuntimeArray args, String fileName, int lineNumber) {
        super();
        this.marker = new ControlFlowMarker(codeRef, args, fileName, lineNumber);
        if (DEBUG_TAILCALL) {
            System.err.println("[DEBUG-0b] RuntimeControlFlowList constructor (codeRef,args): codeRef=" + codeRef + 
                              ", args.size=" + (args != null ? args.size() : "null") + 
                              " @ " + fileName + ":" + lineNumber +
                              " marker.type=" + marker.type);
        }
    }
    
    /**
     * Get the control flow type.
     * 
     * @return The control flow type
     */
    public ControlFlowType getControlFlowType() {
        if (DEBUG_TAILCALL) {
            System.err.println("[DEBUG-2] getControlFlowType() called, returning: " + marker.type);
        }
        return marker.type;
    }
    
    /**
     * Get the control flow label.
     * 
     * @return The label, or null if unlabeled
     */
    public String getControlFlowLabel() {
        return marker.label;
    }
    
    /**
     * Check if this control flow matches the given loop label.
     * Perl semantics:
     * - If control flow is unlabeled (null), it matches any loop
     * - If control flow is labeled and loop is unlabeled (null), no match
     * - If both are labeled, they must match exactly
     * 
     * @param loopLabel The loop label to check against (null for unlabeled loop)
     * @return true if this control flow targets the given loop
     */
    public boolean matchesLabel(String loopLabel) {
        String controlFlowLabel = marker.label;
        
        // Unlabeled control flow (null) matches any loop
        if (controlFlowLabel == null) {
            return true;
        }
        
        // Labeled control flow - check if it matches the loop label
        return controlFlowLabel.equals(loopLabel);
    }
    
    /**
     * Get the tail call code reference.
     * 
     * @return The code reference, or null if not a tail call
     */
    public RuntimeScalar getTailCallCodeRef() {
        if (DEBUG_TAILCALL) {
            System.err.println("[DEBUG-3] getTailCallCodeRef() called, returning: " + marker.codeRef);
        }
        return marker.codeRef;
    }
    
    /**
     * Get the tail call arguments.
     * 
     * @return The arguments, or null if not a tail call
     */
    public RuntimeArray getTailCallArgs() {
        if (DEBUG_TAILCALL) {
            System.err.println("[DEBUG-4] getTailCallArgs() called, returning: " + 
                              (marker.args != null ? marker.args.size() + " args" : "null"));
        }
        return marker.args;
    }
    
    /**
     * Debug method - print this control flow list's details.
     * Can be called from generated bytecode or Java code.
     */
    public RuntimeControlFlowList debugTrace(String context) {
        System.err.println("[TRACE] " + context + ": " + this);
        if (marker != null) {
            marker.debugPrint(context);
        }
        return this;  // Return self for chaining
    }
}

