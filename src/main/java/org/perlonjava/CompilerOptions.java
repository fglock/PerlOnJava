package org.perlonjava;

import org.perlonjava.runtime.GlobalVariable;
import org.perlonjava.runtime.RuntimeArray;
import org.perlonjava.runtime.RuntimeScalar;
import org.perlonjava.runtime.ScalarUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * CompilerOptions is a configuration class that holds various settings and flags
 * used by the compiler during the compilation process. These settings determine
 * how the compiler behaves, including whether to enable debugging, disassembly,
 * or whether to stop the process at specific stages like tokenization, parsing,
 * or compiling. It also stores the source code and the filename, if provided.
 * <p>
 * Fields:
 * - debugEnabled: Enables debug mode, providing detailed logging during compilation.
 * - disassembleEnabled: If true, the compiler will disassemble the generated bytecode.
 * - tokenizeOnly: If true, the compiler will only tokenize the input and stop.
 * - parseOnly: If true, the compiler will only parse the input and stop.
 * - compileOnly: If true, the compiler will compile the input but won't execute it.
 * - processOnly: If true, the compiler will process input files without printing lines.
 * - processAndPrint: If true, the compiler will process input files and print each line.
 * - inPlaceEdit: Indicates if in-place editing is enabled.
 * - code: The source code to be compiled.
 * - fileName: The name of the file containing the source code, if any.
 * - inPlaceExtension: The extension used for in-place editing backups.
 * - argumentList: A list of arguments to be passed to the program.
 * - inc: A list of include directories for the compiler.
 * - unicodeStdin/Stdout/Stderr/etc.: Unicode/encoding flags for different I/O streams.
 */
public class CompilerOptions implements Cloneable {
    public boolean debugEnabled = false;
    public boolean disassembleEnabled = false;
    public boolean tokenizeOnly = false;
    public boolean parseOnly = false;
    public boolean compileOnly = false;
    public boolean processOnly = false; // For -n
    public boolean processAndPrint = false; // For -p
    public boolean inPlaceEdit = false; // New field for in-place editing
    public String code = null;
    public boolean codeHasEncoding = false;
    public String fileName = null;
    public String inPlaceExtension = null; // For -i
    public String inputRecordSeparator = "\n";
    public String outputRecordSeparator = null;
    public boolean autoSplit = false; // For -a
    public boolean useVersion = false; // For -E
    // Initialize @ARGV
    public RuntimeArray argumentList = GlobalVariable.getGlobalArray("main::ARGV");
    public RuntimeArray inc = new RuntimeArray();
    public String splitPattern = "' '"; // Default split pattern for -a
    public boolean lineEndingProcessing = false; // For -l
    public boolean usePathEnv = false; // For -S
    public boolean rudimentarySwitchParsing = false; // For -s
    public StringBuilder rudimentarySwitchAssignments = null; // Variable assignments from -s
    public boolean discardLeadingGarbage = false; // For -x
    public boolean isUnicodeSource = false; // Set to true for UTF-16/UTF-32 source files
    public boolean taintMode = false; // For -T
    public boolean allowUnsafeOperations = false; // For -U
    public boolean runUnderDebugger = false; // For -d
    public boolean taintWarnings = false; // For -t
    public String debugFlags = ""; // For -D
    // Unicode/encoding flags for -C switches
    public boolean unicodeStdin = false; // -CS or -CI
    public boolean unicodeStdout = false; // -CO
    public boolean unicodeStderr = false; // -CE
    public boolean unicodeInput = false; // -CI (same as stdin)
    public boolean unicodeOutput = false; // -CO (same as stdout)
    public boolean unicodeArgs = false; // -CA
    public boolean unicodeLocale = false; // -CL
    List<ArgumentParser.ModuleUseStatement> moduleUseStatements = new ArrayList<>(); // For -m -M
    public RuntimeScalar incHook = null; // For storing @INC hook reference

    @Override
    public CompilerOptions clone() {
        try {
            // Use super.clone() to create a shallow copy
            return (CompilerOptions) super.clone();
        } catch (CloneNotSupportedException e) {
            // This shouldn't happen, since we're implementing Cloneable
            throw new AssertionError();
        }
    }

    @Override
    public String toString() {
        return "CompilerOptions{\n" +
                "    debugEnabled=" + debugEnabled + ",\n" +
                "    disassembleEnabled=" + disassembleEnabled + ",\n" +
                "    tokenizeOnly=" + tokenizeOnly + ",\n" +
                "    parseOnly=" + parseOnly + ",\n" +
                "    compileOnly=" + compileOnly + ",\n" +
                "    processOnly=" + processOnly + ",\n" +
                "    processAndPrint=" + processAndPrint + ",\n" +
                "    inPlaceEdit=" + inPlaceEdit + ",\n" +
                "    taintMode=" + taintMode + ",\n" +
                "    allowUnsafeOperations=" + allowUnsafeOperations + ",\n" +
                "    runUnderDebugger=" + runUnderDebugger + ",\n" +
                "    taintWarnings=" + taintWarnings + ",\n" +
                "    debugFlags=" + ScalarUtils.printable(debugFlags) + ",\n" +
                "    code='" + (code != null ? code : "null") + "',\n" +
                "    codeHasEncoding=" + codeHasEncoding + ",\n" +
                "    fileName=" + ScalarUtils.printable(fileName) + ",\n" +
                "    inPlaceExtension=" + ScalarUtils.printable(inPlaceExtension) + ",\n" +
                "    inputRecordSeparator=" + ScalarUtils.printable(inputRecordSeparator) + ",\n" +
                "    outputRecordSeparator=" + ScalarUtils.printable(outputRecordSeparator) + ",\n" +
                "    autoSplit=" + autoSplit + ",\n" +
                "    useVersion=" + useVersion + ",\n" +
                "    lineEndingProcessing=" + lineEndingProcessing + ",\n" +
                "    discardLeadingGarbage=" + discardLeadingGarbage + ",\n" +
                "    splitPattern=" + ScalarUtils.printable(splitPattern) + ",\n" +
                "    argumentList=" + argumentList + ",\n" +
                "    inc=" + inc + ",\n" +
                "    moduleUseStatements=" + moduleUseStatements + ",\n" +
                "    isUnicodeSource=" + isUnicodeSource + ",\n" +
                "    rudimentarySwitchParsing=" + rudimentarySwitchParsing + ",\n" +
                "    unicodeStdin=" + unicodeStdin + ",\n" +
                "    unicodeStdout=" + unicodeStdout + ",\n" +
                "    unicodeStderr=" + unicodeStderr + ",\n" +
                "    unicodeInput=" + unicodeInput + ",\n" +
                "    unicodeOutput=" + unicodeOutput + ",\n" +
                "    unicodeArgs=" + unicodeArgs + ",\n" +
                "    unicodeLocale=" + unicodeLocale + "\n" +
                "}";
    }
}
