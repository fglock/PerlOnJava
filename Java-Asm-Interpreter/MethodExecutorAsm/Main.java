import java.util.*;

/**
 * The Main class serves as the entry point for the Perl-to-Java bytecode compiler and runtime
 * evaluator. It parses Perl code, generates corresponding Java bytecode using ASM, and executes the
 * generated bytecode.
 */
public class Main {

    /**
     * The main method initializes the compilation and execution process.
     *
     * @param args Command-line arguments.
     */
    public static void main(String[] args) {
        try {
            boolean debugEnabled = false; // Default to debugging off
            boolean tokenizeOnly = false;
            boolean parseOnly = false;
            boolean compileOnly = false;

            // Default Perl code to be compiled and executed
            String fileName = "test.pl";
            String code =
                    ""
                    + "my $a = 15 ;"
                    + "my $x = $a ;"
                    + "print $x ;"
                    + "$a = 12 ;"
                    + "print $a ;"
                    + " ( sub { print @_ } )->(88888) ;"
                    + "print $a ;"
                    + "do { $a; if (1) { print 123 } elsif (3) { print 345 } else { print 456 } } ;"
                    + "print \"Finished; value is $a\\n\"; "
                    + "return 5;";

            // Parse command-line arguments
            for (int i = 0; i < args.length; i++) {
                if (args[i].equals("-e") && i + 1 < args.length) {
                    code = args[i + 1]; // Read the code from the command line parameter
                    fileName = "-e";
                    i++; // Skip the next argument as it is the code
                } else if (args[i].equals("--debug")) {
                    debugEnabled = true; // Enable debugging
                } else if (args[i].equals("--tokenize")) {
                    if (parseOnly || compileOnly) {
                        System.err.println("Error: --tokenize cannot be combined with --parse or -c");
                        System.exit(1);
                    }
                    tokenizeOnly = true;
                } else if (args[i].equals("--parse")) {
                    if (tokenizeOnly || compileOnly) {
                        System.err.println("Error: --parse cannot be combined with --tokenize or -c");
                        System.exit(1);
                    }
                    parseOnly = true;
                } else if (args[i].equals("-c")) {
                    if (tokenizeOnly || parseOnly) {
                        System.err.println("Error: -c cannot be combined with --tokenize or --parse");
                        System.exit(1);
                    }
                    compileOnly = true;
                } else {
                    System.err.println("Error: Unrecognized command-line parameter: " + args[i]);
                    System.exit(1); // Exit with status code 1 to indicate an error
                }
            }

            // Create the compiler context
            EmitterContext ctx = new EmitterContext(
                    fileName, // Source filename
                    null, // Java class name
                    new ScopedSymbolTable(), // Top-level symbol table
                    null, // Return label
                    null, // Method visitor
                    null, // Call context
                    false, // Is boxed
                    null,  // errorUtil
                    debugEnabled   // debugEnabled flag
            );

            // Enter a new scope in the symbol table and add special Perl variables
            ctx.symbolTable.enterScope();
            ctx.symbolTable.addVariable("@_"); // Argument list is local variable 0
            ctx.symbolTable.addVariable("wantarray"); // Call context is local variable 1

            ctx.logDebug("parse code: " + code);
            ctx.logDebug("  call context " + ctx.contextType);

            // Create the Token list
            Lexer lexer = new Lexer(code);
            List<Token> tokens = lexer.tokenize(); // Tokenize the Perl code
            if (tokenizeOnly) {
                // Printing the tokens
                for (Token token : tokens) {
                  System.out.println(token);
                }
                System.exit(0); // success
            }

            // Create the AST
            // Create an instance of ErrorMessageUtil with the file name and token list
            ErrorMessageUtil errorUtil = new ErrorMessageUtil(ctx.fileName, tokens);
            Parser parser = new Parser(errorUtil, tokens); // Parse the tokens
            Node ast = parser.parse(); // Generate the abstract syntax tree (AST)
            if (parseOnly) {
                // Printing the ast
                System.out.println(ast);
                System.exit(0); // success
            }
            ctx.logDebug("-- AST:\n" + ast + "--\n");

            // Create the Java class from the AST
            ctx.logDebug("createClassWithMethod");
            // Create a new instance of ErrorMessageUtil, resetting the line counter
            ctx.errorUtil = new ErrorMessageUtil(ctx.fileName, tokens);
            Class<?> generatedClass = ASMMethodCreator.createClassWithMethod(
                    ctx,
                    new String[] {}, // Closure variables
                    ast
            );
            if (compileOnly) {
                System.exit(0); // success
            }

            // Convert the generated class into a Runtime object
            String newClassName = generatedClass.getName();
            Runtime.anonSubs.put(newClassName, generatedClass); // Store the class in the runtime map
            Runtime anonSub = Runtime.make_sub(newClassName); // Create a Runtime instance for the generated class
            Runtime result = anonSub.apply(new Runtime(999), ContextType.SCALAR); // Execute the generated method

            // Print the result of the execution
            ctx.logDebug("Result of generatedMethod: " + result);
        } catch (Exception e) {
            e.printStackTrace(); // Print any exceptions that occur during the process
        }
    }
}

