this is a Lisp-like interpreter using ASM to execute a data structure like (pseudo-code):

    { (class or object), "method name", arg1, arg2 ... }

it can be recursive:

    { (class or object), "method name", arg1, { (class or object), "method name", ... } ... }

non-method "statements" have a string as first argument:

{ "ARG" } retrieve the argument object.

    {"ARG"}

{ "RETURN", null, value } returns the value. RETURN is optional at the end: the method returns the last value.

    { "RETURN", null, new Object[]{ Runtime.class, "make", 5 } }

{ "IF", null, { cond }, { ifBlock }, { elseBlock } } if/else statement. The elseBlock can be null.

    { "IF", null,
        new Object[][]{ { Runtime.class, "is_false" } },                // if condition
        new Object[][]{ { Runtime.class, "print", "if is true" } },     // if block
        new Object[][]{ { Runtime.class, "print", "if is false" } },    // else block
    },

{ "SUB", className, env, body }   defines a subroutine

    // define and call an anonymous subroutine
    { new Object[]{ "SUB",
        "anon.myAnonSub",
        new Object[][]{     // closed variables  { name }
            { "env" },
        },
        new Object[][]{
            { Runtime.class, "print", new Object[]{ "ARG" } },
        }
    }, "apply", new Object[]{ Runtime.class, "make", 55555 } },

{ GETSTATIC, name } retrieves a captured variable in a closure

    { "GETSTATIC", "env" }

{ GETFIELD, name }  retrieves a lexical variable ("my")

    { "GETFIELD", "var" }

// Example usage
MathOperations mathOps = new MathOperations();
Object[] data = {
    System.out, "println", "Starting execution...",
    new Object[]{System.out, "println", new Object[]{mathOps, "add", 5, 3}},
    new Object[]{System.out, "println", new Object[]{mathOps, "multiply", 2, 4}},
    new Object[]{System.out, "println", "Execution finished."}
};
// compile & execute using reflection
 

Compile:

javac -cp ./asm-9.7.jar:. *.java

Run:

java -cp ./asm-9.7.jar:. ASMMethodCreator
