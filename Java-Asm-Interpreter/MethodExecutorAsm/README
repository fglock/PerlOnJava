this is a Lisp-like interpreter using ASM to execute a data structure like (pseudo-code):

    [ (class or object), "method name", arg1, arg2 ... ]

it can be recursive:

    [ (class or object), "method name", arg1, [ (class or object), "method name", ... ] ... ]

non-method "statements" have a string as first argument:

{ "ARG", index, class } retrieve a positional argument. Arguments start in zero.

    {"ARG", 0, Runtime.class}         

{ "RETURN", null value } returns the value. Otherwise, the method returns the last value.

    { "RETURN", null, new Object[]{ Runtime.class, "make", 5 } }

{ "IF", null, { cond }, { ifBlock }, { elseBlock } } if/else statement. The elseBlock can be null.

    { "IF", null,
        new Object[][]{ { Runtime.class, "is_false" } },      // if condition
        new Object[][]{ { Runtime.class, "print", "if is true" } },    // if block
        new Object[][]{ { Runtime.class, "print", "if is false" } },    // else block
    },

// Example usage
MathOperations mathOps = new MathOperations();
Object[] data = {
    System.out, "println", "Starting execution...",
    new Object[]{System.out, "println", new Object[]{mathOps, "add", 5, 3}},
    new Object[]{System.out, "println", new Object[]{mathOps, "multiply", 2, 4}},
    new Object[]{System.out, "println", "Execution finished."}
};
// compile & execute using reflection
 

Compile:

javac -cp ./asm-9.7.jar:. *.java

Run:

java -cp ./asm-9.7.jar:. ASMMethodCreator
