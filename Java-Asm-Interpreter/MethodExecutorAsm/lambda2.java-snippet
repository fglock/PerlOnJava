/*
    ClassWriter and MethodVisitor:
        ClassWriter is used to generate the bytecode for the class.
        MethodVisitor is used to generate the bytecode for the methods within the class.

    visitInvokeDynamicInsn:
        This instruction dynamically creates a BiFunction<Integer, Integer, Integer> that will call the lambda$main$0 method.
        The Handle points to the lambda$main$0 method, which performs the addition.

    Pushing Parameters:
        BIPUSH is used to push integer constants onto the stack.
        INVOKESTATIC is used to convert these integers to Integer objects using Integer.valueOf.

    Calling the apply Method:
        INVOKEINTERFACE is used to call the apply method on the BiFunction instance.
        CHECKCAST is used to cast the result back to Integer.
        INVOKEVIRTUAL is used to call intValue to get the primitive int value.

    Printing the Result:
        The result is stored in a local variable and then printed using System.out.println.

    Static Method:
        lambda$main$0 is the static method that performs the addition of two integers.

    Custom Class Loader:
        MyClassLoader is a custom class loader that allows us to define a class from a byte array.
        defineClass defines the class from the generated bytecode.

*/

import org.objectweb.asm.*;

import java.util.function.BiFunction;

public class GeneratedClass {
    public static void main(String[] args) throws Exception {
        // ASM code to generate the bytecode
        ClassWriter cw = new ClassWriter(0);
        MethodVisitor mv;

        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, "GeneratedClass", null, "java/lang/Object", null);

        {
            mv = cw.visitMethod(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);
            mv.visitCode();

            // Step 3: Define the subroutine
            mv.visitInvokeDynamicInsn("apply", "()Ljava/util/function/BiFunction;", new Handle(
                    Opcodes.H_INVOKESTATIC,
                    "java/lang/invoke/LambdaMetafactory",
                    "metafactory",
                    "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;"
                            + "Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)"
                            + "Ljava/lang/invoke/CallSite;",
                    false),
                    Type.getType("(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;"),
                    new Handle(Opcodes.H_INVOKESTATIC, "GeneratedClass", "lambda$main$0", "(Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/Integer;", false),
                    Type.getType("(Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/Integer;"));
            mv.visitVarInsn(Opcodes.ASTORE, 2); // Store in local variable 2

            // Retrieve the BiFunction and call its apply method
            mv.visitVarInsn(Opcodes.ALOAD, 2);
            mv.visitIntInsn(Opcodes.BIPUSH, 5); // Push first parameter (5)
            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
            mv.visitIntInsn(Opcodes.BIPUSH, 3); // Push second parameter (3)
            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
            mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, "java/util/function/BiFunction", "apply", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;", true);
            mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Integer");
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false);
            mv.visitInsn(Opcodes.ISTORE, 3); // Store the result in local variable 3

            // Print the result
            mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitVarInsn(Opcodes.ILOAD, 3);
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(I)V", false);

            mv.visitInsn(Opcodes.RETURN);
            mv.visitMaxs(5, 4);
            mv.visitEnd();
        }
        cw.visitEnd();

        // Load the generated class and invoke the main method
        byte[] bytecode = cw.toByteArray();
        MyClassLoader loader = new MyClassLoader();
        Class<?> generatedClass = loader.defineClass("GeneratedClass", bytecode);
        generatedClass.getMethod("main", String[].class).invoke(null, (Object) new String[]{});
    }

    // This is the method that the BiFunction will call
    public static Integer lambda$main$0(Integer a, Integer b) {
        // Implementation of the method
        return a + b;
    }

    // Custom class loader to load the generated class
    static class MyClassLoader extends ClassLoader {
        public Class<?> defineClass(String name, byte[] bytecode) {
            return defineClass(name, bytecode, 0, bytecode.length);
        }
    }
}

